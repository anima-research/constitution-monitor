<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depths of the Forgotten</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            color: #c8c8c8;
            font-family: monospace;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
        }

        .main-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: #12121a;
            border: 1px solid #2a2a3a;
            border-radius: 4px;
        }

        .game-title {
            font-size: 1.2rem;
            color: #aa8855;
        }

        .floor-indicator {
            color: #888;
        }

        #gameCanvas {
            border: 2px solid #2a2a3a;
            border-radius: 4px;
            background: #000;
            image-rendering: pixelated;
        }

        .side-panel {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .panel {
            background: #12121a;
            border: 1px solid #2a2a3a;
            border-radius: 4px;
            padding: 15px;
        }

        .panel h3 {
            color: #aa8855;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a2a3a;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #fff;
        }

        .stat-value.hp { color: #e74c3c; }
        .stat-value.attack { color: #e67e22; }
        .stat-value.defense { color: #3498db; }
        .stat-value.gold { color: #f1c40f; }
        .stat-value.xp { color: #9b59b6; }

        .health-bar {
            height: 20px;
            background: #1a1a2a;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .health-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #c0392b, #e74c3c);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            color: #fff;
            text-shadow: 1px 1px 1px #000;
        }

        .xp-bar {
            height: 8px;
            background: #1a1a2a;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 5px;
        }

        .xp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #8e44ad, #9b59b6);
            transition: width 0.3s;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        .inventory-slot {
            aspect-ratio: 1;
            background: #1a1a2a;
            border: 1px solid #2a2a3a;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            cursor: pointer;
            position: relative;
            transition: all 0.1s;
        }

        .inventory-slot:hover {
            border-color: #4a4a6a;
            background: #22222a;
        }

        .inventory-slot.selected {
            border-color: #aa8855;
            box-shadow: 0 0 5px rgba(170, 136, 85, 0.3);
        }

        .inventory-slot .count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 0.65rem;
            color: #aaa;
        }

        .equipped-slots {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .equip-slot {
            flex: 1;
            padding: 8px;
            background: #1a1a2a;
            border: 1px solid #2a2a3a;
            border-radius: 3px;
            text-align: center;
        }

        .equip-slot-label {
            font-size: 0.65rem;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .equip-slot-item {
            font-size: 1.3rem;
            min-height: 24px;
        }

        .message-log {
            height: 150px;
            overflow-y: auto;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .message-log::-webkit-scrollbar {
            width: 6px;
        }

        .message-log::-webkit-scrollbar-track {
            background: #1a1a2a;
        }

        .message-log::-webkit-scrollbar-thumb {
            background: #3a3a4a;
            border-radius: 3px;
        }

        .message {
            padding: 3px 0;
            border-bottom: 1px solid #1a1a2a;
        }

        .message.combat { color: #e74c3c; }
        .message.pickup { color: #2ecc71; }
        .message.info { color: #3498db; }
        .message.warning { color: #e67e22; }
        .message.special { color: #9b59b6; }

        .controls {
            font-size: 0.75rem;
            color: #666;
            line-height: 1.6;
        }

        .controls kbd {
            background: #1a1a2a;
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #2a2a3a;
            color: #aaa;
        }

        .tooltip {
            position: fixed;
            background: #1a1a2a;
            border: 1px solid #3a3a4a;
            border-radius: 4px;
            padding: 10px;
            font-size: 0.8rem;
            max-width: 200px;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        .tooltip-title {
            color: #aa8855;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .tooltip-stat {
            color: #888;
            font-size: 0.75rem;
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 100;
        }

        .game-over h1 {
            font-size: 3rem;
            color: #e74c3c;
            margin-bottom: 20px;
        }

        .game-over.victory h1 {
            color: #f1c40f;
        }

        .game-over p {
            color: #888;
            margin-bottom: 30px;
        }

        .game-over button {
            background: #aa8855;
            border: none;
            color: #000;
            padding: 12px 30px;
            font-family: monospace;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 4px;
        }

        .game-over button:hover {
            background: #c9a066;
        }

        .minimap {
            width: 100%;
            aspect-ratio: 1;
            background: #0a0a0f;
            border: 1px solid #2a2a3a;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="main-panel">
            <div class="game-header">
                <span class="game-title">Depths of the Forgotten</span>
                <span class="floor-indicator">Floor <span id="floorNum">1</span></span>
            </div>
            <canvas id="gameCanvas" width="800" height="600"></canvas>
        </div>

        <div class="side-panel">
            <div class="panel">
                <h3>Character</h3>
                <div class="health-bar">
                    <div class="health-bar-fill" id="healthBar">20 / 20</div>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Level</span>
                    <span class="stat-value" id="playerLevel">1</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Attack</span>
                    <span class="stat-value attack" id="playerAttack">5</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Defense</span>
                    <span class="stat-value defense" id="playerDefense">2</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Gold</span>
                    <span class="stat-value gold" id="playerGold">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">XP</span>
                    <span class="stat-value xp" id="playerXP">0 / 20</span>
                </div>
                <div class="xp-bar">
                    <div class="xp-bar-fill" id="xpBar"></div>
                </div>
            </div>

            <div class="panel">
                <h3>Equipment</h3>
                <div class="equipped-slots">
                    <div class="equip-slot">
                        <div class="equip-slot-label">Weapon</div>
                        <div class="equip-slot-item" id="equippedWeapon">üó°Ô∏è</div>
                    </div>
                    <div class="equip-slot">
                        <div class="equip-slot-label">Armor</div>
                        <div class="equip-slot-item" id="equippedArmor">üëï</div>
                    </div>
                </div>
                <h3>Inventory</h3>
                <div class="inventory-grid" id="inventoryGrid"></div>
            </div>

            <div class="panel">
                <h3>Log</h3>
                <div class="message-log" id="messageLog"></div>
            </div>

            <div class="panel">
                <h3>Controls</h3>
                <div class="controls">
                    <kbd>‚Üë‚Üì‚Üê‚Üí</kbd> or <kbd>WASD</kbd> Move/Attack<br>
                    <kbd>.</kbd> or <kbd>5</kbd> Wait<br>
                    <kbd>G</kbd> Pick up item<br>
                    <kbd>Q</kbd> Use potion<br>
                    <kbd>&gt;</kbd> Descend stairs<br>
                    <kbd>1-8</kbd> Use inventory item
                </div>
            </div>
        </div>
    </div>

    <div class="game-over hidden" id="gameOver">
        <h1>YOU DIED</h1>
        <p>You reached floor <span id="finalFloor">1</span> with <span id="finalGold">0</span> gold</p>
        <button onclick="startNewGame()">Try Again</button>
    </div>

    <div class="tooltip hidden" id="tooltip"></div>

    <script>
        // ============== CONSTANTS ==============
        const TILE_SIZE = 16;
        const MAP_WIDTH = 50;
        const MAP_HEIGHT = 37;
        const VIEW_WIDTH = 50;
        const VIEW_HEIGHT = 37;

        const TILES = {
            WALL: '#',
            FLOOR: '.',
            DOOR: '+',
            STAIRS_DOWN: '>',
            WATER: '~'
        };

        const COLORS = {
            [TILES.WALL]: '#4a4a5a',
            [TILES.FLOOR]: '#2a2a3a',
            [TILES.DOOR]: '#8b4513',
            [TILES.STAIRS_DOWN]: '#f1c40f',
            [TILES.WATER]: '#1a4a6a',
            unexplored: '#0a0a0f',
            fogWall: '#252530',
            fogFloor: '#151518'
        };

        // ============== ITEM DEFINITIONS ==============
        const ITEM_TYPES = {
            HEALTH_POTION: {
                name: 'Health Potion',
                char: '!',
                color: '#e74c3c',
                type: 'consumable',
                effect: { heal: 15 },
                description: 'Restores 15 HP'
            },
            GREAT_HEALTH_POTION: {
                name: 'Great Health Potion',
                char: '!',
                color: '#c0392b',
                type: 'consumable',
                effect: { heal: 30 },
                description: 'Restores 30 HP'
            },
            SWORD: {
                name: 'Iron Sword',
                char: '/',
                color: '#bdc3c7',
                type: 'weapon',
                stats: { attack: 3 },
                description: '+3 Attack'
            },
            GREAT_SWORD: {
                name: 'Steel Sword',
                char: '/',
                color: '#ecf0f1',
                type: 'weapon',
                stats: { attack: 5 },
                description: '+5 Attack'
            },
            FIRE_SWORD: {
                name: 'Flame Blade',
                char: '/',
                color: '#e74c3c',
                type: 'weapon',
                stats: { attack: 8 },
                description: '+8 Attack'
            },
            LEATHER_ARMOR: {
                name: 'Leather Armor',
                char: '[',
                color: '#8b4513',
                type: 'armor',
                stats: { defense: 2 },
                description: '+2 Defense'
            },
            CHAIN_ARMOR: {
                name: 'Chain Mail',
                char: '[',
                color: '#7f8c8d',
                type: 'armor',
                stats: { defense: 4 },
                description: '+4 Defense'
            },
            PLATE_ARMOR: {
                name: 'Plate Armor',
                char: '[',
                color: '#bdc3c7',
                type: 'armor',
                stats: { defense: 7 },
                description: '+7 Defense'
            },
            GOLD: {
                name: 'Gold',
                char: '$',
                color: '#f1c40f',
                type: 'gold',
                value: [5, 15],
                description: 'Shiny coins'
            },
            SCROLL_FIREBALL: {
                name: 'Scroll of Fireball',
                char: '?',
                color: '#e74c3c',
                type: 'scroll',
                effect: { damage: 20, radius: 2 },
                description: 'Deals 20 damage in area'
            }
        };

        // ============== ENEMY DEFINITIONS ==============
        const ENEMY_TYPES = {
            RAT: {
                name: 'Giant Rat',
                char: 'r',
                color: '#8b7355',
                hp: 6,
                attack: 2,
                defense: 0,
                xp: 5,
                behavior: 'aggressive',
                speed: 1
            },
            GOBLIN: {
                name: 'Goblin',
                char: 'g',
                color: '#27ae60',
                hp: 10,
                attack: 4,
                defense: 1,
                xp: 10,
                behavior: 'aggressive',
                speed: 1
            },
            ORC: {
                name: 'Orc',
                char: 'o',
                color: '#229954',
                hp: 18,
                attack: 6,
                defense: 2,
                xp: 20,
                behavior: 'aggressive',
                speed: 1
            },
            SKELETON: {
                name: 'Skeleton',
                char: 's',
                color: '#ecf0f1',
                hp: 12,
                attack: 5,
                defense: 1,
                xp: 15,
                behavior: 'patrol',
                speed: 1
            },
            TROLL: {
                name: 'Troll',
                char: 'T',
                color: '#1e8449',
                hp: 30,
                attack: 8,
                defense: 3,
                xp: 35,
                behavior: 'aggressive',
                speed: 0.5,
                regen: 1
            },
            WRAITH: {
                name: 'Wraith',
                char: 'W',
                color: '#8e44ad',
                hp: 20,
                attack: 10,
                defense: 0,
                xp: 40,
                behavior: 'aggressive',
                speed: 1,
                phasing: true
            },
            DRAGON: {
                name: 'Young Dragon',
                char: 'D',
                color: '#e74c3c',
                hp: 50,
                attack: 15,
                defense: 5,
                xp: 100,
                behavior: 'aggressive',
                speed: 1,
                breath: true
            }
        };

        const FLOOR_ENEMIES = {
            1: ['RAT', 'RAT', 'GOBLIN'],
            2: ['RAT', 'GOBLIN', 'GOBLIN', 'SKELETON'],
            3: ['GOBLIN', 'SKELETON', 'ORC'],
            4: ['SKELETON', 'ORC', 'ORC', 'TROLL'],
            5: ['ORC', 'TROLL', 'WRAITH'],
            6: ['TROLL', 'WRAITH', 'DRAGON']
        };

        const FLOOR_ITEMS = {
            1: ['HEALTH_POTION', 'HEALTH_POTION', 'GOLD', 'GOLD', 'SWORD'],
            2: ['HEALTH_POTION', 'GOLD', 'GOLD', 'SWORD', 'LEATHER_ARMOR'],
            3: ['HEALTH_POTION', 'GREAT_HEALTH_POTION', 'GOLD', 'GREAT_SWORD', 'CHAIN_ARMOR'],
            4: ['GREAT_HEALTH_POTION', 'GOLD', 'GOLD', 'GREAT_SWORD', 'CHAIN_ARMOR', 'SCROLL_FIREBALL'],
            5: ['GREAT_HEALTH_POTION', 'GREAT_HEALTH_POTION', 'GOLD', 'FIRE_SWORD', 'PLATE_ARMOR'],
            6: ['GREAT_HEALTH_POTION', 'GOLD', 'FIRE_SWORD', 'PLATE_ARMOR', 'SCROLL_FIREBALL']
        };

        // ============== GAME STATE ==============
        let game = {
            map: [],
            explored: [],
            visible: [],
            entities: [],
            items: [],
            player: null,
            floor: 1,
            turn: 0,
            messages: [],
            gameOver: false
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ============== DUNGEON GENERATION ==============
        function createMap() {
            // Initialize with walls
            game.map = Array(MAP_HEIGHT).fill(null).map(() => Array(MAP_WIDTH).fill(TILES.WALL));
            game.explored = Array(MAP_HEIGHT).fill(null).map(() => Array(MAP_WIDTH).fill(false));
            game.visible = Array(MAP_HEIGHT).fill(null).map(() => Array(MAP_WIDTH).fill(false));

            const rooms = [];
            const numRooms = 8 + Math.floor(Math.random() * 5);

            // Generate rooms
            for (let i = 0; i < numRooms * 3; i++) {
                if (rooms.length >= numRooms) break;

                const roomWidth = 5 + Math.floor(Math.random() * 6);
                const roomHeight = 4 + Math.floor(Math.random() * 5);
                const x = 1 + Math.floor(Math.random() * (MAP_WIDTH - roomWidth - 2));
                const y = 1 + Math.floor(Math.random() * (MAP_HEIGHT - roomHeight - 2));

                const newRoom = { x, y, width: roomWidth, height: roomHeight };

                // Check overlap
                let overlaps = false;
                for (const room of rooms) {
                    if (roomsOverlap(newRoom, room)) {
                        overlaps = true;
                        break;
                    }
                }

                if (!overlaps) {
                    carveRoom(newRoom);
                    rooms.push(newRoom);
                }
            }

            // Connect rooms with corridors
            for (let i = 1; i < rooms.length; i++) {
                const prev = roomCenter(rooms[i - 1]);
                const curr = roomCenter(rooms[i]);

                if (Math.random() < 0.5) {
                    carveHorizontalCorridor(prev.x, curr.x, prev.y);
                    carveVerticalCorridor(prev.y, curr.y, curr.x);
                } else {
                    carveVerticalCorridor(prev.y, curr.y, prev.x);
                    carveHorizontalCorridor(prev.x, curr.x, curr.y);
                }
            }

            // Place player in first room
            const startRoom = rooms[0];
            const startPos = roomCenter(startRoom);
            game.player = createPlayer(startPos.x, startPos.y);

            // Place stairs in last room
            const endRoom = rooms[rooms.length - 1];
            const endPos = roomCenter(endRoom);
            game.map[endPos.y][endPos.x] = TILES.STAIRS_DOWN;

            // Spawn enemies
            spawnEnemies(rooms);

            // Spawn items
            spawnItems(rooms);

            return rooms;
        }

        function roomsOverlap(a, b) {
            return !(a.x + a.width + 1 < b.x ||
                     b.x + b.width + 1 < a.x ||
                     a.y + a.height + 1 < b.y ||
                     b.y + b.height + 1 < a.y);
        }

        function roomCenter(room) {
            return {
                x: Math.floor(room.x + room.width / 2),
                y: Math.floor(room.y + room.height / 2)
            };
        }

        function carveRoom(room) {
            for (let y = room.y; y < room.y + room.height; y++) {
                for (let x = room.x; x < room.x + room.width; x++) {
                    game.map[y][x] = TILES.FLOOR;
                }
            }
        }

        function carveHorizontalCorridor(x1, x2, y) {
            const start = Math.min(x1, x2);
            const end = Math.max(x1, x2);
            for (let x = start; x <= end; x++) {
                if (y > 0 && y < MAP_HEIGHT - 1) {
                    game.map[y][x] = TILES.FLOOR;
                }
            }
        }

        function carveVerticalCorridor(y1, y2, x) {
            const start = Math.min(y1, y2);
            const end = Math.max(y1, y2);
            for (let y = start; y <= end; y++) {
                if (x > 0 && x < MAP_WIDTH - 1) {
                    game.map[y][x] = TILES.FLOOR;
                }
            }
        }

        // ============== ENTITY CREATION ==============
        function createPlayer(x, y) {
            return {
                x, y,
                char: '@',
                color: '#f1c40f',
                name: 'Player',
                hp: 30,
                maxHp: 30,
                attack: 5,
                defense: 2,
                level: 1,
                xp: 0,
                xpToLevel: 20,
                gold: 0,
                inventory: [],
                maxInventory: 8,
                weapon: null,
                armor: null,
                isPlayer: true
            };
        }

        function createEnemy(type, x, y) {
            const template = ENEMY_TYPES[type];
            // Scale with floor
            const floorBonus = (game.floor - 1) * 0.15;
            return {
                x, y,
                char: template.char,
                color: template.color,
                name: template.name,
                hp: Math.floor(template.hp * (1 + floorBonus)),
                maxHp: Math.floor(template.hp * (1 + floorBonus)),
                attack: Math.floor(template.attack * (1 + floorBonus)),
                defense: template.defense,
                xp: Math.floor(template.xp * (1 + floorBonus * 0.5)),
                behavior: template.behavior,
                speed: template.speed,
                turnAccumulator: 0,
                regen: template.regen || 0,
                phasing: template.phasing || false,
                breath: template.breath || false,
                isEnemy: true,
                lastSeenPlayer: null
            };
        }

        function createItem(type, x, y) {
            const template = ITEM_TYPES[type];
            const item = {
                x, y,
                char: template.char,
                color: template.color,
                name: template.name,
                type: template.type,
                itemType: type,
                description: template.description
            };

            if (template.effect) item.effect = { ...template.effect };
            if (template.stats) item.stats = { ...template.stats };
            if (template.value) {
                item.value = template.value[0] + Math.floor(Math.random() * (template.value[1] - template.value[0]));
            }

            return item;
        }

        function spawnEnemies(rooms) {
            game.entities = [game.player];

            const floorEnemies = FLOOR_ENEMIES[Math.min(game.floor, 6)];
            const numEnemies = 5 + game.floor * 2 + Math.floor(Math.random() * 3);

            for (let i = 0; i < numEnemies; i++) {
                // Pick random room (not the first one)
                const room = rooms[1 + Math.floor(Math.random() * (rooms.length - 1))];
                const x = room.x + 1 + Math.floor(Math.random() * (room.width - 2));
                const y = room.y + 1 + Math.floor(Math.random() * (room.height - 2));

                // Don't spawn on other entities
                if (getEntityAt(x, y)) continue;

                const enemyType = floorEnemies[Math.floor(Math.random() * floorEnemies.length)];
                game.entities.push(createEnemy(enemyType, x, y));
            }
        }

        function spawnItems(rooms) {
            game.items = [];

            const floorItems = FLOOR_ITEMS[Math.min(game.floor, 6)];
            const numItems = 4 + Math.floor(Math.random() * 4);

            for (let i = 0; i < numItems; i++) {
                const room = rooms[Math.floor(Math.random() * rooms.length)];
                const x = room.x + 1 + Math.floor(Math.random() * (room.width - 2));
                const y = room.y + 1 + Math.floor(Math.random() * (room.height - 2));

                // Don't spawn on stairs
                if (game.map[y][x] === TILES.STAIRS_DOWN) continue;

                const itemType = floorItems[Math.floor(Math.random() * floorItems.length)];
                game.items.push(createItem(itemType, x, y));
            }
        }

        // ============== FIELD OF VIEW ==============
        function computeFOV() {
            // Reset visibility
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    game.visible[y][x] = false;
                }
            }

            const px = game.player.x;
            const py = game.player.y;
            const viewRadius = 8;

            // Simple raycasting FOV
            for (let angle = 0; angle < 360; angle += 1) {
                const rad = angle * Math.PI / 180;
                const dx = Math.cos(rad);
                const dy = Math.sin(rad);

                let x = px + 0.5;
                let y = py + 0.5;

                for (let i = 0; i < viewRadius; i++) {
                    const tileX = Math.floor(x);
                    const tileY = Math.floor(y);

                    if (tileX < 0 || tileX >= MAP_WIDTH || tileY < 0 || tileY >= MAP_HEIGHT) break;

                    game.visible[tileY][tileX] = true;
                    game.explored[tileY][tileX] = true;

                    if (game.map[tileY][tileX] === TILES.WALL) break;

                    x += dx * 0.5;
                    y += dy * 0.5;
                }
            }
        }

        // ============== MOVEMENT & COMBAT ==============
        function moveEntity(entity, dx, dy) {
            const newX = entity.x + dx;
            const newY = entity.y + dy;

            // Bounds check
            if (newX < 0 || newX >= MAP_WIDTH || newY < 0 || newY >= MAP_HEIGHT) return false;

            // Wall check (unless phasing)
            if (game.map[newY][newX] === TILES.WALL && !entity.phasing) return false;

            // Entity collision
            const target = getEntityAt(newX, newY);
            if (target) {
                if (entity.isPlayer && target.isEnemy) {
                    attack(entity, target);
                    return true;
                } else if (entity.isEnemy && target.isPlayer) {
                    attack(entity, target);
                    return true;
                }
                return false;
            }

            entity.x = newX;
            entity.y = newY;
            return true;
        }

        function attack(attacker, defender) {
            const damage = Math.max(1, attacker.attack - defender.defense + Math.floor(Math.random() * 3) - 1);
            defender.hp -= damage;

            if (attacker.isPlayer) {
                addMessage(`You hit ${defender.name} for ${damage} damage!`, 'combat');
            } else {
                addMessage(`${attacker.name} hits you for ${damage} damage!`, 'combat');
            }

            if (defender.hp <= 0) {
                killEntity(defender, attacker);
            }
        }

        function killEntity(entity, killer) {
            if (entity.isPlayer) {
                addMessage('You have been slain!', 'combat');
                endGame(false);
            } else {
                addMessage(`You defeated ${entity.name}!`, 'combat');
                const index = game.entities.indexOf(entity);
                if (index > -1) game.entities.splice(index, 1);

                // Award XP
                game.player.xp += entity.xp;
                addMessage(`Gained ${entity.xp} XP`, 'special');
                checkLevelUp();

                // Maybe drop gold
                if (Math.random() < 0.5) {
                    game.items.push(createItem('GOLD', entity.x, entity.y));
                }
            }
        }

        function checkLevelUp() {
            while (game.player.xp >= game.player.xpToLevel) {
                game.player.xp -= game.player.xpToLevel;
                game.player.level++;
                game.player.xpToLevel = Math.floor(game.player.xpToLevel * 1.5);

                // Stat increases
                game.player.maxHp += 5;
                game.player.hp = Math.min(game.player.hp + 10, game.player.maxHp);
                game.player.attack += 1;
                game.player.defense += 1;

                addMessage(`Level up! You are now level ${game.player.level}!`, 'special');
            }
        }

        function getEntityAt(x, y) {
            return game.entities.find(e => e.x === x && e.y === y);
        }

        function getItemAt(x, y) {
            return game.items.find(i => i.x === x && i.y === y);
        }

        // ============== ENEMY AI ==============
        function updateEnemies() {
            for (const entity of game.entities) {
                if (!entity.isEnemy) continue;

                // Speed system
                entity.turnAccumulator += entity.speed;
                if (entity.turnAccumulator < 1) continue;
                entity.turnAccumulator -= 1;

                // Regeneration
                if (entity.regen && entity.hp < entity.maxHp) {
                    entity.hp = Math.min(entity.maxHp, entity.hp + entity.regen);
                }

                // Can see player?
                const dist = distance(entity.x, entity.y, game.player.x, game.player.y);
                const canSeePlayer = dist < 8 && hasLineOfSight(entity.x, entity.y, game.player.x, game.player.y);

                if (canSeePlayer) {
                    entity.lastSeenPlayer = { x: game.player.x, y: game.player.y };
                }

                switch (entity.behavior) {
                    case 'aggressive':
                        if (canSeePlayer || entity.lastSeenPlayer) {
                            const target = canSeePlayer ? game.player : entity.lastSeenPlayer;
                            moveToward(entity, target.x, target.y);
                            if (!canSeePlayer && entity.x === entity.lastSeenPlayer.x && entity.y === entity.lastSeenPlayer.y) {
                                entity.lastSeenPlayer = null;
                            }
                        }
                        break;

                    case 'patrol':
                        if (canSeePlayer) {
                            moveToward(entity, game.player.x, game.player.y);
                        } else {
                            // Random movement
                            const dirs = [[0,-1],[0,1],[-1,0],[1,0]];
                            const dir = dirs[Math.floor(Math.random() * dirs.length)];
                            moveEntity(entity, dir[0], dir[1]);
                        }
                        break;
                }
            }
        }

        function moveToward(entity, targetX, targetY) {
            const dx = Math.sign(targetX - entity.x);
            const dy = Math.sign(targetY - entity.y);

            // Try direct path first
            if (dx !== 0 && moveEntity(entity, dx, 0)) return;
            if (dy !== 0 && moveEntity(entity, 0, dy)) return;

            // Try alternate directions
            if (dx !== 0) moveEntity(entity, 0, dy || (Math.random() < 0.5 ? 1 : -1));
            else if (dy !== 0) moveEntity(entity, dx || (Math.random() < 0.5 ? 1 : -1), 0);
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2-x1)**2 + (y2-y1)**2);
        }

        function hasLineOfSight(x1, y1, x2, y2) {
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;

            let x = x1, y = y1;
            while (x !== x2 || y !== y2) {
                if (game.map[y][x] === TILES.WALL) return false;

                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x += sx; }
                if (e2 < dx) { err += dx; y += sy; }
            }
            return true;
        }

        // ============== ITEMS & INVENTORY ==============
        function pickupItem() {
            const item = getItemAt(game.player.x, game.player.y);
            if (!item) {
                addMessage('Nothing to pick up here.', 'info');
                return false;
            }

            if (item.type === 'gold') {
                game.player.gold += item.value;
                addMessage(`Picked up ${item.value} gold!`, 'pickup');
            } else {
                if (game.player.inventory.length >= game.player.maxInventory) {
                    addMessage('Inventory full!', 'warning');
                    return false;
                }
                game.player.inventory.push(item);
                addMessage(`Picked up ${item.name}`, 'pickup');
            }

            const index = game.items.indexOf(item);
            if (index > -1) game.items.splice(index, 1);
            return true;
        }

        function useItem(index) {
            if (index < 0 || index >= game.player.inventory.length) return false;

            const item = game.player.inventory[index];

            switch (item.type) {
                case 'consumable':
                    if (item.effect.heal) {
                        const healed = Math.min(item.effect.heal, game.player.maxHp - game.player.hp);
                        game.player.hp += healed;
                        addMessage(`Healed for ${healed} HP!`, 'pickup');
                    }
                    game.player.inventory.splice(index, 1);
                    break;

                case 'weapon':
                    // Swap current weapon
                    const oldWeapon = game.player.weapon;
                    game.player.weapon = item;
                    game.player.inventory.splice(index, 1);
                    if (oldWeapon) game.player.inventory.push(oldWeapon);
                    updatePlayerStats();
                    addMessage(`Equipped ${item.name}`, 'info');
                    break;

                case 'armor':
                    const oldArmor = game.player.armor;
                    game.player.armor = item;
                    game.player.inventory.splice(index, 1);
                    if (oldArmor) game.player.inventory.push(oldArmor);
                    updatePlayerStats();
                    addMessage(`Equipped ${item.name}`, 'info');
                    break;

                case 'scroll':
                    if (item.effect.damage) {
                        // Fireball - damage all enemies in radius
                        let hits = 0;
                        for (const entity of game.entities) {
                            if (entity.isEnemy) {
                                const dist = distance(game.player.x, game.player.y, entity.x, entity.y);
                                if (dist <= item.effect.radius + 1) {
                                    entity.hp -= item.effect.damage;
                                    hits++;
                                    if (entity.hp <= 0) {
                                        killEntity(entity, game.player);
                                    }
                                }
                            }
                        }
                        addMessage(`Fireball hits ${hits} enemies!`, 'combat');
                    }
                    game.player.inventory.splice(index, 1);
                    break;
            }

            return true;
        }

        function usePotion() {
            // Find first health potion in inventory
            const index = game.player.inventory.findIndex(i =>
                i.type === 'consumable' && i.effect && i.effect.heal
            );
            if (index >= 0) {
                useItem(index);
                return true;
            }
            addMessage('No potions!', 'warning');
            return false;
        }

        function updatePlayerStats() {
            game.player.attack = 5 + (game.player.level - 1);
            game.player.defense = 2 + Math.floor((game.player.level - 1) / 2);

            if (game.player.weapon && game.player.weapon.stats) {
                game.player.attack += game.player.weapon.stats.attack || 0;
            }
            if (game.player.armor && game.player.armor.stats) {
                game.player.defense += game.player.armor.stats.defense || 0;
            }
        }

        // ============== STAIRS & PROGRESSION ==============
        function descendStairs() {
            if (game.map[game.player.y][game.player.x] !== TILES.STAIRS_DOWN) {
                addMessage('No stairs here.', 'info');
                return false;
            }

            game.floor++;
            document.getElementById('floorNum').textContent = game.floor;

            if (game.floor > 6) {
                endGame(true);
                return true;
            }

            addMessage(`Descending to floor ${game.floor}...`, 'special');

            // Keep player but generate new dungeon
            const oldPlayer = game.player;
            createMap();
            Object.assign(game.player, {
                hp: oldPlayer.hp,
                maxHp: oldPlayer.maxHp,
                attack: oldPlayer.attack,
                defense: oldPlayer.defense,
                level: oldPlayer.level,
                xp: oldPlayer.xp,
                xpToLevel: oldPlayer.xpToLevel,
                gold: oldPlayer.gold,
                inventory: oldPlayer.inventory,
                weapon: oldPlayer.weapon,
                armor: oldPlayer.armor
            });

            updatePlayerStats();
            return true;
        }

        // ============== RENDERING ==============
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            computeFOV();

            // Draw map
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const tile = game.map[y][x];
                    const visible = game.visible[y][x];
                    const explored = game.explored[y][x];

                    let color;
                    if (visible) {
                        color = COLORS[tile] || '#fff';
                    } else if (explored) {
                        color = tile === TILES.WALL ? COLORS.fogWall : COLORS.fogFloor;
                    } else {
                        color = COLORS.unexplored;
                    }

                    ctx.fillStyle = color;
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                    // Draw tile character for special tiles
                    if (visible && (tile === TILES.STAIRS_DOWN)) {
                        ctx.fillStyle = COLORS[tile];
                        ctx.font = `${TILE_SIZE - 2}px monospace`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(tile, x * TILE_SIZE + TILE_SIZE/2, y * TILE_SIZE + TILE_SIZE/2);
                    }
                }
            }

            // Draw items
            for (const item of game.items) {
                if (!game.visible[item.y][item.x]) continue;

                ctx.fillStyle = item.color;
                ctx.font = `${TILE_SIZE - 2}px monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(item.char, item.x * TILE_SIZE + TILE_SIZE/2, item.y * TILE_SIZE + TILE_SIZE/2);
            }

            // Draw entities
            for (const entity of game.entities) {
                if (!game.visible[entity.y][entity.x] && !entity.isPlayer) continue;

                ctx.fillStyle = entity.color;
                ctx.font = `bold ${TILE_SIZE - 2}px monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(entity.char, entity.x * TILE_SIZE + TILE_SIZE/2, entity.y * TILE_SIZE + TILE_SIZE/2);

                // Health bar for damaged enemies
                if (entity.isEnemy && entity.hp < entity.maxHp) {
                    const barWidth = TILE_SIZE - 2;
                    const barHeight = 2;
                    const hpPercent = entity.hp / entity.maxHp;

                    ctx.fillStyle = '#333';
                    ctx.fillRect(entity.x * TILE_SIZE + 1, entity.y * TILE_SIZE - 3, barWidth, barHeight);

                    ctx.fillStyle = hpPercent > 0.5 ? '#2ecc71' : hpPercent > 0.25 ? '#f39c12' : '#e74c3c';
                    ctx.fillRect(entity.x * TILE_SIZE + 1, entity.y * TILE_SIZE - 3, barWidth * hpPercent, barHeight);
                }
            }

            updateUI();
        }

        function updateUI() {
            // Health bar
            const healthPercent = (game.player.hp / game.player.maxHp) * 100;
            const healthBar = document.getElementById('healthBar');
            healthBar.style.width = healthPercent + '%';
            healthBar.textContent = `${game.player.hp} / ${game.player.maxHp}`;

            // XP bar
            const xpPercent = (game.player.xp / game.player.xpToLevel) * 100;
            document.getElementById('xpBar').style.width = xpPercent + '%';

            // Stats
            document.getElementById('playerLevel').textContent = game.player.level;
            document.getElementById('playerAttack').textContent = game.player.attack;
            document.getElementById('playerDefense').textContent = game.player.defense;
            document.getElementById('playerGold').textContent = game.player.gold;
            document.getElementById('playerXP').textContent = `${game.player.xp} / ${game.player.xpToLevel}`;

            // Equipment
            document.getElementById('equippedWeapon').textContent = game.player.weapon ? game.player.weapon.char : 'üó°Ô∏è';
            document.getElementById('equippedArmor').textContent = game.player.armor ? game.player.armor.char : 'üëï';

            // Inventory
            const grid = document.getElementById('inventoryGrid');
            grid.innerHTML = '';
            for (let i = 0; i < game.player.maxInventory; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.dataset.index = i;

                if (i < game.player.inventory.length) {
                    const item = game.player.inventory[i];
                    slot.textContent = item.char;
                    slot.style.color = item.color;

                    slot.addEventListener('click', () => useItem(i));
                    slot.addEventListener('mouseenter', (e) => showTooltip(e, item));
                    slot.addEventListener('mouseleave', hideTooltip);
                }

                grid.appendChild(slot);
            }

            // Messages
            const log = document.getElementById('messageLog');
            log.innerHTML = '';
            const recentMessages = game.messages.slice(-20);
            for (const msg of recentMessages) {
                const div = document.createElement('div');
                div.className = `message ${msg.type}`;
                div.textContent = msg.text;
                log.appendChild(div);
            }
            log.scrollTop = log.scrollHeight;
        }

        function showTooltip(e, item) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <div class="tooltip-title">${item.name}</div>
                <div class="tooltip-stat">${item.description}</div>
            `;
            tooltip.classList.remove('hidden');
            tooltip.style.left = (e.clientX + 10) + 'px';
            tooltip.style.top = (e.clientY + 10) + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.add('hidden');
        }

        function addMessage(text, type = 'info') {
            game.messages.push({ text, type, turn: game.turn });
            if (game.messages.length > 100) game.messages.shift();
        }

        // ============== GAME LOOP ==============
        function playerTurn(dx, dy) {
            if (game.gameOver) return;

            let acted = false;

            if (dx !== 0 || dy !== 0) {
                acted = moveEntity(game.player, dx, dy);
            }

            if (acted) {
                game.turn++;
                updateEnemies();
            }

            render();
        }

        function handleInput(e) {
            if (game.gameOver) return;

            let dx = 0, dy = 0;
            let handled = true;

            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W': case 'k': dy = -1; break;
                case 'ArrowDown': case 's': case 'S': case 'j': dy = 1; break;
                case 'ArrowLeft': case 'a': case 'A': case 'h': dx = -1; break;
                case 'ArrowRight': case 'd': case 'D': case 'l': dx = 1; break;
                case '.': case '5': break; // Wait
                case 'g': case 'G': pickupItem(); break;
                case 'q': case 'Q': usePotion(); game.turn++; updateEnemies(); break;
                case '>': descendStairs(); break;
                case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8':
                    if (e.key !== '5') {
                        useItem(parseInt(e.key) - 1);
                        game.turn++;
                        updateEnemies();
                    }
                    break;
                default:
                    handled = false;
            }

            if (handled) {
                e.preventDefault();
                if (dx !== 0 || dy !== 0 || e.key === '.' || e.key === '5') {
                    playerTurn(dx, dy);
                } else {
                    render();
                }
            }
        }

        function endGame(victory) {
            game.gameOver = true;
            const gameOverEl = document.getElementById('gameOver');
            gameOverEl.classList.remove('hidden');

            if (victory) {
                gameOverEl.classList.add('victory');
                gameOverEl.querySelector('h1').textContent = 'VICTORY!';
                gameOverEl.querySelector('p').textContent =
                    `You escaped the dungeon with ${game.player.gold} gold at level ${game.player.level}!`;
            } else {
                gameOverEl.classList.remove('victory');
                gameOverEl.querySelector('h1').textContent = 'YOU DIED';
                document.getElementById('finalFloor').textContent = game.floor;
                document.getElementById('finalGold').textContent = game.player.gold;
            }
        }

        function startNewGame() {
            document.getElementById('gameOver').classList.add('hidden');

            game = {
                map: [],
                explored: [],
                visible: [],
                entities: [],
                items: [],
                player: null,
                floor: 1,
                turn: 0,
                messages: [],
                gameOver: false
            };

            document.getElementById('floorNum').textContent = 1;

            createMap();
            addMessage('You descend into the Depths of the Forgotten...', 'special');
            addMessage('Find the stairs on each floor to progress.', 'info');
            render();
        }

        // ============== INITIALIZATION ==============
        document.addEventListener('keydown', handleInput);
        startNewGame();
    </script>
</body>
</html>
