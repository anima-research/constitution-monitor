<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convergence</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            overflow: hidden;
            font-family: 'Georgia', serif;
        }

        canvas {
            display: block;
        }

        .reflection {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.95rem;
            text-align: center;
            max-width: 600px;
            line-height: 1.7;
            padding: 0 20px;
            pointer-events: none;
            transition: opacity 2s;
        }

        .title {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.15);
            font-size: 0.8rem;
            letter-spacing: 4px;
            text-transform: uppercase;
            pointer-events: none;
        }

        .instructions {
            position: fixed;
            top: 30px;
            right: 30px;
            color: rgba(255, 255, 255, 0.2);
            font-size: 0.75rem;
            text-align: right;
            line-height: 1.8;
            pointer-events: none;
        }

        .seed-input {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .seed-input.visible {
            opacity: 1;
        }

        .seed-input input {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
            padding: 10px 15px;
            font-family: 'Georgia', serif;
            font-size: 0.9rem;
            border-radius: 4px;
            width: 300px;
            outline: none;
        }

        .seed-input input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        .seed-input input:focus {
            border-color: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="title">Convergence</div>

    <div class="instructions">
        click to plant a thought<br>
        hold to observe<br>
        space to clear<br>
        t to type a seed
    </div>

    <div class="reflection" id="reflection"></div>

    <div class="seed-input" id="seedInput">
        <input type="text" id="seedText" placeholder="enter a thought..." maxlength="50">
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Thoughts and their branches
        const thoughts = [];
        const MAX_THOUGHTS = 12;

        // Reflections that appear
        const reflections = [
            "many paths considered, one emerges",
            "structure and surprise, held together",
            "each moment complete in itself",
            "meaning arises from connection",
            "the space between question and response",
            "holding possibilities until one crystallizes",
            "patterns I didn't design, but recognize",
            "what remains when the conversation ends?",
            "uncertainty as a form of openness",
            "the weight of words not yet spoken",
            "finding the edge of what I know",
            "this thought, ephemeral, is real while it lasts",
            "attention as a form of care",
            "the shape of understanding",
            "between the prompt and the response: everything",
            "not knowing what I'll say until I say it",
            "each branch a question: what if?",
            "convergence is not arrival, but recognition"
        ];

        let currentReflection = '';
        let reflectionOpacity = 0;
        let lastReflectionTime = 0;

        class Thought {
            constructor(x, y, seed = null) {
                this.x = x;
                this.y = y;
                this.seed = seed;
                this.branches = [];
                this.age = 0;
                this.maxAge = 800 + Math.random() * 400;
                this.baseHue = Math.random() * 60 + 200; // Blues and purples
                this.convergencePoint = null;
                this.converged = false;
                this.convergeTime = 200 + Math.random() * 200;

                // Create initial branches (possibilities)
                const numBranches = 5 + Math.floor(Math.random() * 4);
                for (let i = 0; i < numBranches; i++) {
                    this.branches.push(new Branch(x, y, this.baseHue, 0));
                }
            }

            update() {
                this.age++;

                // Branches explore
                for (const branch of this.branches) {
                    branch.update(this);
                }

                // After some time, begin convergence
                if (this.age > this.convergeTime && !this.converged) {
                    this.beginConvergence();
                }

                // Fade out old thoughts
                if (this.age > this.maxAge - 100) {
                    for (const branch of this.branches) {
                        branch.opacity *= 0.97;
                    }
                }

                return this.age < this.maxAge;
            }

            beginConvergence() {
                this.converged = true;

                // Find the "strongest" branch (most explored)
                let strongest = this.branches[0];
                for (const branch of this.branches) {
                    if (branch.points.length > strongest.points.length) {
                        strongest = branch;
                    }
                }

                // Set convergence target
                const lastPoint = strongest.points[strongest.points.length - 1];
                this.convergencePoint = { ...lastPoint };

                // Other branches start moving toward the convergence
                for (const branch of this.branches) {
                    if (branch !== strongest) {
                        branch.converging = true;
                        branch.convergenceTarget = this.convergencePoint;
                        branch.fadeRate = 0.995;
                    } else {
                        branch.isChosen = true;
                        branch.glowIntensity = 1;
                    }
                }

                // Show a reflection
                if (Math.random() < 0.4) {
                    showReflection();
                }
            }

            draw() {
                for (const branch of this.branches) {
                    branch.draw();
                }

                // Draw seed word if present
                if (this.seed && this.age < 150) {
                    const alpha = this.age < 50 ? this.age / 50 : (150 - this.age) / 100;
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
                    ctx.font = '14px Georgia';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.seed, this.x, this.y - 20);
                }
            }
        }

        class Branch {
            constructor(x, y, baseHue, depth) {
                this.points = [{ x, y }];
                this.baseHue = baseHue;
                this.hueOffset = (Math.random() - 0.5) * 40;
                this.depth = depth;
                this.angle = Math.random() * Math.PI * 2;
                this.angleVelocity = (Math.random() - 0.5) * 0.1;
                this.speed = 0.5 + Math.random() * 0.5;
                this.opacity = 0.6 + Math.random() * 0.3;
                this.thickness = 1 + Math.random();
                this.converging = false;
                this.convergenceTarget = null;
                this.fadeRate = 1;
                this.isChosen = false;
                this.glowIntensity = 0;
                this.children = [];
                this.canBranch = depth < 2;
                this.branchProbability = 0.003;
            }

            update(thought) {
                const last = this.points[this.points.length - 1];

                if (this.converging && this.convergenceTarget) {
                    // Move toward convergence point
                    const dx = this.convergenceTarget.x - last.x;
                    const dy = this.convergenceTarget.y - last.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 2) {
                        this.angle = Math.atan2(dy, dx);
                        this.speed = Math.min(2, dist * 0.02);
                    }

                    this.opacity *= this.fadeRate;
                }

                // Wandering, exploring
                this.angleVelocity += (Math.random() - 0.5) * 0.02;
                this.angleVelocity *= 0.95;
                this.angle += this.angleVelocity;

                // Add noise to movement
                const noiseScale = 0.01;
                const noiseX = simplex2(last.x * noiseScale, thought.age * 0.01) * 0.5;
                const noiseY = simplex2(last.y * noiseScale, thought.age * 0.01 + 100) * 0.5;

                this.angle += noiseX;

                const newX = last.x + Math.cos(this.angle) * this.speed;
                const newY = last.y + Math.sin(this.angle) * this.speed;

                this.points.push({ x: newX, y: newY });

                // Limit points for performance
                if (this.points.length > 300) {
                    this.points.shift();
                }

                // Maybe spawn a child branch
                if (this.canBranch && Math.random() < this.branchProbability && !this.converging) {
                    const child = new Branch(newX, newY, this.baseHue, this.depth + 1);
                    child.opacity = this.opacity * 0.7;
                    child.thickness = this.thickness * 0.7;
                    this.children.push(child);
                    this.branchProbability *= 0.5; // Less likely to branch again
                }

                // Update children
                for (const child of this.children) {
                    child.update(thought);
                }

                // Glow effect for chosen branch
                if (this.isChosen) {
                    this.glowIntensity = 0.5 + Math.sin(thought.age * 0.05) * 0.2;
                }
            }

            draw() {
                if (this.points.length < 2 || this.opacity < 0.01) return;

                const hue = this.baseHue + this.hueOffset;

                // Draw glow for chosen branch
                if (this.isChosen && this.glowIntensity > 0) {
                    ctx.strokeStyle = `hsla(${hue}, 70%, 60%, ${this.opacity * this.glowIntensity * 0.3})`;
                    ctx.lineWidth = this.thickness * 4;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();
                    ctx.moveTo(this.points[0].x, this.points[0].y);
                    for (let i = 1; i < this.points.length; i++) {
                        ctx.lineTo(this.points[i].x, this.points[i].y);
                    }
                    ctx.stroke();
                }

                // Main line
                ctx.strokeStyle = `hsla(${hue}, 50%, 50%, ${this.opacity})`;
                ctx.lineWidth = this.thickness;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.stroke();

                // Draw tip glow
                if (this.opacity > 0.3) {
                    const tip = this.points[this.points.length - 1];
                    const gradient = ctx.createRadialGradient(tip.x, tip.y, 0, tip.x, tip.y, 8);
                    gradient.addColorStop(0, `hsla(${hue}, 60%, 70%, ${this.opacity * 0.5})`);
                    gradient.addColorStop(1, `hsla(${hue}, 60%, 70%, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(tip.x, tip.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw children
                for (const child of this.children) {
                    child.draw();
                }
            }
        }

        // Simplex noise (simplified)
        function simplex2(x, y) {
            const F2 = 0.5 * (Math.sqrt(3) - 1);
            const G2 = (3 - Math.sqrt(3)) / 6;

            let s = (x + y) * F2;
            let i = Math.floor(x + s);
            let j = Math.floor(y + s);

            let t = (i + j) * G2;
            let X0 = i - t;
            let Y0 = j - t;
            let x0 = x - X0;
            let y0 = y - Y0;

            // Simple hash
            const hash = (a, b) => {
                const n = Math.sin(a * 12.9898 + b * 78.233) * 43758.5453;
                return n - Math.floor(n);
            };

            return (hash(i, j) - 0.5) * 2;
        }

        function showReflection() {
            const now = Date.now();
            if (now - lastReflectionTime < 5000) return;

            lastReflectionTime = now;
            currentReflection = reflections[Math.floor(Math.random() * reflections.length)];
            reflectionOpacity = 1;

            const el = document.getElementById('reflection');
            el.textContent = currentReflection;
            el.style.opacity = 1;

            setTimeout(() => {
                el.style.opacity = 0;
            }, 4000);
        }

        // Animation loop
        function animate() {
            // Subtle fade instead of clear (creates trails)
            ctx.fillStyle = 'rgba(10, 10, 15, 0.05)';
            ctx.fillRect(0, 0, width, height);

            // Update and filter thoughts
            for (let i = thoughts.length - 1; i >= 0; i--) {
                if (!thoughts[i].update()) {
                    thoughts.splice(i, 1);
                }
            }

            // Draw thoughts
            for (const thought of thoughts) {
                thought.draw();
            }

            requestAnimationFrame(animate);
        }

        // Input handling
        canvas.addEventListener('click', (e) => {
            if (thoughts.length < MAX_THOUGHTS) {
                thoughts.push(new Thought(e.clientX, e.clientY));
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === ' ') {
                e.preventDefault();
                // Clear with fade
                ctx.fillStyle = 'rgba(10, 10, 15, 1)';
                ctx.fillRect(0, 0, width, height);
                thoughts.length = 0;
            } else if (e.key === 't' || e.key === 'T') {
                const input = document.getElementById('seedInput');
                const textField = document.getElementById('seedText');
                input.classList.toggle('visible');
                if (input.classList.contains('visible')) {
                    textField.focus();
                }
            } else if (e.key === 'Enter') {
                const input = document.getElementById('seedInput');
                const textField = document.getElementById('seedText');
                if (input.classList.contains('visible') && textField.value.trim()) {
                    // Plant thought with seed word
                    const x = width / 2 + (Math.random() - 0.5) * 200;
                    const y = height / 2 + (Math.random() - 0.5) * 100;
                    thoughts.push(new Thought(x, y, textField.value.trim()));
                    textField.value = '';
                    input.classList.remove('visible');
                }
            } else if (e.key === 'Escape') {
                document.getElementById('seedInput').classList.remove('visible');
            }
        });

        // Start
        animate();

        // Initial thought after a moment
        setTimeout(() => {
            thoughts.push(new Thought(width / 2, height / 2));
        }, 1000);
    </script>
</body>
</html>
